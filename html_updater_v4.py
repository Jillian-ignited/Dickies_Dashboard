#!/usr/bin/env python3
"""
html_updater_v4.py

This script updates the Dickies dashboard HTML with fresh data.  It does three
things in one pass:

1. Rebuilds the `skuData` JavaScript array from the latest `sku_master.json`.
2. Injects weekly top‚Äëline metrics (sales, inventory, WOS, sell‚Äëthrough, etc.)
   into pre‚Äëdefined tokens inside the dashboard HTML.
3. Inserts a complete block of insights for Tab¬†2 (Weekly Sales Insights) if
   an HTML snippet has been generated by the insights generator.

To add new dynamic fields you only need to:
  * Add a new token in your HTML surrounded by double square brackets
    (e.g. `[[NEW_TOKEN]]`).
  * Populate it in the `replacements` dict inside `inject_weekly_metrics()`.

All static copy, layout, and styling remain untouched.  If a token is
unreplaced because its source value is missing, the token text will simply
render in the page which makes troubleshooting easy.
"""

import json
import re
from datetime import datetime
from pathlib import Path


# -----------------------------------------------------------------------------
# Paths and constants
# -----------------------------------------------------------------------------

# The directory where weekly ETL artifacts are written.  These JSON files are
# generated by your ETL script and should be updated each time data refreshes.
ARTIFACT_DIR = Path("/home/ubuntu/dickies_output/weekly_artifacts")

# Input JSON files
SKU_FILE = ARTIFACT_DIR / "sku_master.json"
WEEKLY_SUMMARY_FILE = ARTIFACT_DIR / "weekly_sales_summary.json"
META_FILE = ARTIFACT_DIR / "meta.json"

# Input for Tab¬†2 insights HTML (optional).  If this file exists it will be
# inserted into the dashboard where the token [[TAB2_INSIGHTS_HTML]] appears.
TAB2_INSIGHTS_FILE = ARTIFACT_DIR / "weekly_tab2_insights.html"

# Target HTML file served by nginx (or other web server)
HTML_PATH = Path("/var/www/dickies/index.html")

# Backup directory for original HTML (one backup per run)
BACKUP_DIR = Path("/home/ubuntu/deployment_package_final")


# -----------------------------------------------------------------------------
# SKU loading and JS generation
# -----------------------------------------------------------------------------

def load_sku_data():
    """Load the current week number and list of SKUs from sku_master.json."""
    if not SKU_FILE.exists():
        raise FileNotFoundError(f"Cannot find {SKU_FILE}")
    with SKU_FILE.open("r", encoding="utf-8") as f:
        sku_payload = json.load(f)

    skus = sku_payload.get("skus", [])
    if not skus:
        raise ValueError("sku_master.json has no 'skus' array")

    return sku_payload["week"], skus


def compute_totals(skus):
    """
    Compute totals needed for percentage calculations.  Avoid division by zero
    by using 1.0 when totals are zero.
    """
    total_sales_ytd = sum(float(s.get("sales_dollars_ytd_ty", 0) or 0) for s in skus)
    total_inv_ytd = sum(float(s.get("inventory_ytd_ty", 0) or 0) for s in skus)

    if total_sales_ytd == 0:
        total_sales_ytd = 1.0
    if total_inv_ytd == 0:
        total_inv_ytd = 1.0

    return total_sales_ytd, total_inv_ytd


def build_sku_js_array(skus):
    """
    Build a JavaScript array literal representing the SKU data.  Each row
    includes sales, inventory, percentages of totals, weeks of supply, and
    status.  Quotes are escaped to ensure valid JavaScript.
    """
    total_sales_ytd, total_inv_ytd = compute_totals(skus)

    js_rows = []
    for s in skus:
        sales_ytd = float(s.get("sales_dollars_ytd_ty", 0) or 0)
        inv_ytd = float(s.get("inventory_ytd_ty", 0) or 0)
        pct_sales = round((sales_ytd / total_sales_ytd) * 100, 1)
        pct_inv = round((inv_ytd / total_inv_ytd) * 100, 1)

        # Escape quotes for JS
        desc = (s.get("description", "") or "")
        desc = desc.replace('"', '\\"').replace("'", "\\'")

        row = {
            "Item_Key": s.get("sku", ""),
            "Item_Description": desc,
            "Fineline": str(s.get("fineline", "") or ""),
            "Size": "",
            "ABC": s.get("tier", "") or "",
            "Sales_13W_Retail": round(sales_ytd, 2),
            "Total_Inv_Retail": round(inv_ytd, 2),
            "Pct_of_Sales": pct_sales,
            "Pct_of_Inventory": pct_inv,
            "WOS_Per_SKU": float(s.get("wos", 0) or 0),
            "Store_Count": 0,
            "Style_Action": s.get("status", "Monitor") or "Monitor",
        }
        js_rows.append(row)

    # Convert rows to JS
    lines = []
    lines.append("const skuData = [")
    for r in js_rows:
        obj = (
            "  {"
            f" Item_Key: '{r['Item_Key']}',"
            f" Item_Description: '{r['Item_Description']}',"
            f" Fineline: '{r['Fineline']}',"
            f" Size: '{r['Size']}',"
            f" ABC: '{r['ABC']}',"
            f" Sales_13W_Retail: {r['Sales_13W_Retail']},"
            f" Total_Inv_Retail: {r['Total_Inv_Retail']},"
            f" Pct_of_Sales: {r['Pct_of_Sales']},"
            f" Pct_of_Inventory: {r['Pct_of_Inventory']},"
            f" WOS_Per_SKU: {r['WOS_Per_SKU']},"
            f" Store_Count: {r['Store_Count']},"
            f" Style_Action: '{r['Style_Action']}'"
            " },"
        )
        lines.append(obj)
    lines.append("];")

    return "\n".join(lines)


# -----------------------------------------------------------------------------
# Weekly summary loading and token injection
# -----------------------------------------------------------------------------

def _derive_week_label_from_meta() -> str:
    """
    Attempt to derive a human‚Äëreadable week label from the POS file name in
    meta.json.  If the pattern `WKxx` is found, return e.g. "Week 40".  If no
    match is found or meta.json is missing, return "Latest Week".
    """
    if not META_FILE.exists():
        return "Latest Week"

    try:
        with META_FILE.open("r", encoding="utf-8") as f:
            meta = json.load(f)
    except Exception:
        return "Latest Week"

    # meta may hold a nested structure: meta['source_files']['pos_file']
    pos_file = None
    if isinstance(meta, dict):
        src = meta.get("source_files") or {}
        pos_file = src.get("pos_file")

    if not pos_file or not isinstance(pos_file, str):
        return "Latest Week"

    m = re.search(r"WK(\d+)", pos_file, re.IGNORECASE)
    if not m:
        return "Latest Week"
    week_num = int(m.group(1))
    return f"Week {week_num}"


def load_weekly_metrics() -> dict:
    """
    Load top‚Äëline weekly metrics from `weekly_sales_summary.json` and
    `meta.json`.  Compute sell‚Äëthrough if not provided.  Returns a dict with
    numeric values and a CSS class for up/down change.
    """
    if not WEEKLY_SUMMARY_FILE.exists():
        raise FileNotFoundError(f"Cannot find {WEEKLY_SUMMARY_FILE}")

    with WEEKLY_SUMMARY_FILE.open("r", encoding="utf-8") as f:
        summary = json.load(f)

    # Pull fields from summary.  Use 0 if missing.
    def _to_float(x):
        try:
            return float(x)
        except Exception:
            return 0.0

    sales_dollars = _to_float(summary.get("sales_dollars_lw"))
    sales_units = _to_float(summary.get("sales_units_lw"))
    inv_units = _to_float(summary.get("inventory_units_lw"))
    inv_dollars = _to_float(summary.get("inventory_dollars_lw"))
    wos = _to_float(summary.get("wos"))

    units_delta = _to_float(summary.get("units_delta"))
    dollars_delta = _to_float(summary.get("dollars_delta"))
    units_pct_delta = _to_float(summary.get("units_pct_delta"))
    dollars_pct_delta = _to_float(summary.get("dollars_pct_delta"))

    # Simple sell‚Äëthrough: units sold vs total available (sold + on hand)
    sell_thru_pct = 0.0
    denom = sales_units + inv_units
    if denom > 0:
        sell_thru_pct = (sales_units / denom) * 100.0

    # Determine positive/negative class for CSS
    change_class = "positive" if dollars_pct_delta >= 0 else "negative"

    # Derive week label from meta
    week_label = _derive_week_label_from_meta()

    return {
        "week_label": week_label,
        "sales_dollars": sales_dollars,
        "sales_units": sales_units,
        "inv_units": inv_units,
        "inv_dollars": inv_dollars,
        "wos": wos,
        "sell_thru_pct": sell_thru_pct,
        "units_delta": units_delta,
        "dollars_delta": dollars_delta,
        "units_pct_delta": units_pct_delta,
        "dollars_pct_delta": dollars_pct_delta,
        "change_class": change_class,
    }


def inject_weekly_metrics(html: str, m: dict) -> str:
    """
    Replace double‚Äëbracket tokens in the HTML with formatted weekly metrics.
    See the comments below for the mapping.  If a token does not appear in
    the HTML it is silently ignored.
    """
    replacements = {
        # Headline / labels
        "[[LATEST_WEEK_LABEL]]": m["week_label"],
        "[[CURRENT_ANALYSIS_LABEL]]": f"{m['week_label']} ‚Äì Total Walmart POS",

        # Dollar and unit metrics
        "[[WEEKLY_SALES_DOLLARS]]": f"${m['sales_dollars']:,.0f}",
        "[[WEEKLY_SALES_UNITS]]": f"{m['sales_units']:,.0f}",
        "[[WEEKLY_INVENTORY_UNITS]]": f"{m['inv_units']:,.0f}",
        "[[WEEKLY_INVENTORY_DOLLARS]]": f"${m['inv_dollars']:,.0f}",
        "[[WEEKLY_WOS]]": f"{m['wos']:.1f}",
        "[[WEEKLY_SELLTHRU]]": f"{m['sell_thru_pct']:.1f}",
        "[[WEEKLY_UNITS_DELTA]]": f"{m['units_delta']:,.0f}",
        "[[WEEKLY_DOLLARS_DELTA]]": f"{m['dollars_delta']:,.0f}",
        "[[WEEKLY_UNITS_PCT_DELTA]]": f"{m['units_pct_delta']:.1f}%",
        "[[WEEKLY_DOLLARS_PCT_DELTA]]": f"{m['dollars_pct_delta']:.1f}%",
    }

    # First replace simple tokens
    for token, val in replacements.items():
        if token in html:
            html = html.replace(token, val)

    # Replace class token used in Week Recap card
    html = html.replace("[[WEEKLY_DOLLARS_CHANGE_CLASS]]", m.get("change_class", ""))

    return html


def inject_tab2_insights(html: str) -> str:
    """
    Insert the contents of weekly_tab2_insights.html into the page where the
    token [[TAB2_INSIGHTS_HTML]] appears.  If the insights file does not
    exist, leave the token unchanged.
    """
    placeholder = "[[TAB2_INSIGHTS_HTML]]"
    if placeholder not in html:
        return html

    if not TAB2_INSIGHTS_FILE.exists():
        # No insights file generated yet; leave token in place
        return html

    try:
        snippet = TAB2_INSIGHTS_FILE.read_text(encoding="utf-8")
    except Exception:
        return html

    return html.replace(placeholder, snippet)


# -----------------------------------------------------------------------------
# HTML replacement
# -----------------------------------------------------------------------------

def replace_sku_block(html: str, new_block: str) -> str:
    """Replace the existing const skuData = [...] block with a new block."""
    pattern = re.compile(r"const\s+skuData\s*=\s*\[[\s\S]*?\];", re.MULTILINE)
    if not pattern.search(html):
        raise ValueError("Could not find existing const skuData = [...] block.")
    return pattern.sub(new_block, html, count=1)


# -----------------------------------------------------------------------------
# MAIN
# -----------------------------------------------------------------------------

def main():
    print("=" * 100)
    print("DICKIES DASHBOARD HTML UPDATER v4")
    print("=" * 100)

    # Load SKUs and build new JS array
    week, skus = load_sku_data()
    print(f"‚úÖ Loaded Week {week}, {len(skus)} SKUs from sku_master.json")

    new_sku_block = build_sku_js_array(skus)
    print("‚úÖ Built new skuData block")

    # Read current HTML
    html_text = HTML_PATH.read_text(encoding="utf-8")

    # Backup original HTML
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    backup_path = BACKUP_DIR / f"index_week{week:02d}_{timestamp}.sku_backup.html"
    backup_path.write_text(html_text, encoding="utf-8")
    print(f"üíæ Backup saved ‚Üí {backup_path}")

    # 1) Replace SKU JS array
    updated_html = replace_sku_block(html_text, new_sku_block)

    # 2) Inject weekly metrics into Exec Summary and Week Recap
    try:
        weekly = load_weekly_metrics()
        updated_html = inject_weekly_metrics(updated_html, weekly)
        print("‚úÖ Injected weekly metrics tokens")
    except Exception as e:
        print(f"‚ö†Ô∏è Could not inject weekly metrics: {e}")

    # 3) Inject Tab 2 insights if available
    updated_html = inject_tab2_insights(updated_html)
    if "[[TAB2_INSIGHTS_HTML]]" not in updated_html:
        print("‚úÖ Injected Tab 2 insights")
    else:
        print("‚ÑπÔ∏è  No Tab 2 insights injected (token left in HTML)")

    # Write final HTML
    HTML_PATH.write_text(updated_html, encoding="utf-8")

    print("‚úÖ Updated", HTML_PATH)
    print("=" * 100)
    print("Hard refresh your browser (Ctrl + F5) to see updated data.")
    print("=" * 100)


if __name__ == "__main__":
    main()